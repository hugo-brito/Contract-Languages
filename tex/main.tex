\documentclass{ituthesis}



\settitle{Domain-Specific Languages\\for Analysing Contracts}
\setauthor{Hugo Brito \\ \href{mailto:hubr@itu.dk}{hubr@itu.dk} \\ \\ Jonas Andersen \\ \href{mailto:haja@itu.dk}{haja@itu.dk}}
\setsupervisor{Willard Rafnsson}
\setextrasupervisor{Patrick Bahr}
\setdate{December 2019}

\begin{document}
% Uncomment the following to set the default language of the document to Danish. This affects hyphenation as well as headers and the like.
%\selectlanguage{danish}

% no hyphenation
\hyphenchar\font=-1

\frontmatter

\thetitlepage
\newpage

\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter

%from memoir documentation:
%TeX tries very hard to keep text lines justified while keeping the interword spacing as constant as possible, but sometimes fails and complains about an overfull hbox.
%The default mode for LaTeX typesetting is \fussy where the (variation of) interword spacing in justified text is kept to a minimum. Following the \sloppy declaration there may be a much looser setting of justified text.
%Additionally the class provides the \midsloppy declaration which allows a setting somewhere between \fussy and \sloppy.
%fewer overfull lines than \fussy, and fewer obvious large interword spacing than with \sloppy.
%the memoir manual also uses \midsloppy!
\midsloppy
% try harder to avoid widows and orphans
\sloppybottom

\chapter{Introduction}

Picture the scenario of a banking institution with thousands of requests per day for their financial products, being those in the form of home loans, credit cards, personal loans, etc. How could one assess those requests in a timely manner? How could one even manage all active contracts? How would it be in the case of a breached contract? Certainly not with pen and paper.

In this digital era, contracts have become digital. In this paper we will implement and discuss a framework for expressing contracts digitally by the means of contract-specification language. The goal is to design a prototype language for expressing contracts between parties --- commitments between them that will later be checked against actual taken actions. Having the first in place, and then informing the program of the latter will result on the evaluation of the remainder of the given contract. This means to know what commitments are yet to be fulfilled or, if the current contract has been breached, or if it has finished successfully (all parties have delivered what they promised).

This framework will allow its users to:
\begin{itemize}
    \item Build templates for contracts of many kinds --- a simple purchase, a loan, exchange of currency.
    \item Manage active contracts.
    \item Reason about both contract templates and potential contracts, and even to build strong contract templates that disallow negative effects on both parties, among others.
\end{itemize}

\section{What is a Contract?}
\label{contract}
The concept of contract will often arise throughout this paper. In this context, we resort to the definition of contract by Hvitved:
\begin{displayquote}
\textit{"A contract is a legally binding agreement between two or more parties. The agreement is a normative description of commitments between the parties of the contract, that is a contract describes the expected actions to be performed by the participants of the contract."}
\cite{hvitved2011contract}
\end{displayquote}

Since contracts normally are described in natural language, they can be expressed in many different ways, and can even be more or less precise in their definition as the language used to describe them. Them always define a set of obligations between parties to express a business transaction. See the example on Figure \ref{fig:exampleContract}. 
\begin{figure}[!h]
\begin{tcolorbox}
\begin{itemize}
    \item Alice wishes to buy a bike from Bob.
    \item Upon ordering, Alice shall the bike price set by Bob of 100€.
    \item Upon receiving the money, Bob shall deliver the bike to Alice.
\end{itemize}
\end{tcolorbox}
\caption{Example contract.}
\label{fig:exampleContract}
\end{figure}

\section{What Is a Domain-Specific Language?}
% Does it answer the question: What are Contract Languages used for?

As previously mentioned, we wish to easily express and reason about contracts. To achieve this, we built a prototype which consists of a domain-specific language. A domain-specific language (DSL) is a programming language tailored to a specific problem domain \cite{whatsisadsl2005}. Whereas with a general-purpose programming language, which use is not restricted to a particular type of problem or machine, a DSL is built with the sole purpose of modelling and expressing a specific set of problems \cite{van2000domain}. %comment from willard: Consider a different citation style ("plain", or, if you need a little more, "alpha")., not sure what he means.
Typically, it is less complex to use than a general-purpose programming language and it is meant to be developed in close contact with domain experts, as ultimately these will constitute its users \cite{dsl}.

\section{What Is a Contract Language?}
A contract language (CL), or contract-specification language, is a DSL tailored for contracts. Its purpose is to express contracts so that they can be treated as data --- this allows for analysis of the given contract through the possible executions of the business transaction, to see if something unexpected can occur. By having this in place, one can effectively manage all aspects of the given contract.

One example is when modelling a contract, one can assume that it is composed of a limited set of commitment between parties. If it is known that one party has fulfilled one of the commitments, very easily the remainder can be evaluated, e.g. the set of remaining commitments that are yet to be fulfilled is returned. Moreover, these contracts are subjected to monitoring and various user-defined analyses \cite{andersen2006compositional}.

Approaches to modelling contracts could diverge immensely, but we focus on contracts that are unambiguous in their nature, such as financial contracts and in general contracts governing the exchange of resources.

\section{Problem Formulation}
With the ultimate goal of coming up with a prototype of language to build and evaluate contracts, this paper reports on:
\begin{itemize}
    \item A domain-specific language built for the purpose of expressing and operating on contracts digitally.
    \item The aspects considered --- including background, language design and expressiveness ---  when building the present prototype language.
    \item The implementation of the language.
    \item A discussion regarding the strengths and pitfalls of this particular implementation.
\end{itemize}
Even though the motivation for doing this analysis was originated from the possibility of testing contracts (and doing that by resorting to property-based testing), we have shifted the focus of this project and present only work related to contract definition and execution.

\chapter{Methodology}
In this paper we use the inductive approach to determine how to develop our contract language. This chapter summarises the state of the art of contract specification languages, and points out relevant aspects to consider when defining a language of this nature.

\section{Background}
DSLs have been around almost as long as the the existence of humans, as we always find a way to simplify language within certain domains. Musicians use musical notation, lawyers use legal-language and we programmers use code. Nowadays most programmers use general-purpose languages that might contain DSLs to make the solving of certain problems easier, whereas older languages such as SQL\footnote{«\textit{SQL, which stands for Structured Query Language, is a programming language that is used to communicate with and manipulate databases.}» \cite{whatisSQL}} were made as dedicated languages to solve a certain range of problems \cite{van2000domain}.

\subsection{} % name of the peyton language

However, the idea of using a DSL to give a formal description to contracts in code, was not introduced until the 2000s by Peyton-Jones et al. They specifically explored how to express financial contracts, such as bonds, stocks, etc.\ to build a combinator library \cite{peyton2000composing}. This type of DSL is known as a contract language. To this day, contract languages are still most commonly used in the domain of the financial industry.

\subsection{} % deon digital language

Andersen et al.\ have taken an extra step by building a general contract language that can encompass more than just financial contracts, and they have done so by extending Peyton-Jones et al.\'s language. This language formalises contracts governing the exchange of resources, hence it encompasses the exchange of money, goods and services among multiple parties \cite{andersen2006compositional}. The aforementioned paper laid the groundwork for the contract language developed by Deon Digital\footnote{\url{https://www.deondigital.com/}}, which has provided us with valuable guidance on how to approach, design and build our own contract language.

\subsection{«a Trace-Based Model for Multiparty Contracts»}

Blame assignment was introduced in the «a Trace-Based Model for Multiparty Contracts» paper \cite{hvitved2012trace}. Before, it was possible to discern if, when and why a contract had been breached, but not by whom. Blame assignment considers who the perpetrator is by adding substantial value to the field, as knowing the origin of the breach can potentially save a lot of time by avoiding court. It also reports contract breaches as the contract is being executed. These can come, for example, in the form of a deadline that has not been respected, the act of executing some action explicitly forbidden by the contract, etc. Being able to model contracts that account for these aspects has been proven as a very effective way to describe real-world contracts. A noticeable advantage of this is being able to simulate possible outcomes of future events and to issue reminders for deadlines that are closing in --- which could potentially make the difference between breaching a contract or not, and as a result being able to avoid paying for repairs/compensation \cite{hvitved2012trace}.

\subsection{«Certified Symbolic Management of Financial Multi-Party Contracts»}

It is a widely accepted idea that faulty software is costly and can potentially compromise an entire project \cite{expensivesoftware}. With the broader adoption of DSLs by many financial organisations, the concerns regarding correctness (by means of mathematical proof) and the ability to simultaneously express useful, real-world contracts has emerged. An important development in the field has been the idea of abstracting the aspects of simulation and computation of a contract from the core of the language the contract is specified in. This idea allows to bring algebraic properties closer to the formalisation of contracts and, by doing so, allowing for symbolic (rather than numerical) computation and mathematical proof --- this work has been elaborated on the «Certified Symbolic Management of Financial Multi-party Contracts» paper \cite{bahr2015certified}, where a contract language is presented along with a type system that enforces that contracts specified in such language follow the principle of causality. These findings also allow for implementations within contract management, a feature that is certainly appreciated by these institutions since they have many contracts and parties to manage. Other features of the language described in aforementioned paper include type inference, reduction semantics, contract specialisation (partial evaluation), and horizon inference. Overall, and perhaps one of the most interesting aspects this paper brings is the robustness in the language brought by certification of its properties by using the Coq proof
assistant\footnote{Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs. More info: \url{https://github.com/coq/coq}}.

\section{Why a DSL for Contracts?}
What is the gain in implementing and using a DSL for contracts? The previous section answers a big portion of this question, but it is important to mention that one of the main benefits of formalising contracts using a DSL is that it allows for automated contract life-cycle management (CLM). CLM deals with managing a contract portfolio, specifically the creation, negotiation, approval, execution and analysis of contracts. By having a CSL in place, one can handle the parts of CLM that require validation, execution and analysis of contracts \cite{hvitved2011contract}.

\section{Contract Formalisation Requirements} \label{requirements}
When formalising contracts it is vital to consider a formal contract model and a formal contract language separately. A formal model refers to a semantic mathematical model of a contract while a formal language refers to a syntactic representation of a contract. When creating a contract language both of these should ideally be combined in terms of the language's semantics \cite{hvitved2011contract}. In this paper focuses solely on implementing the semantics in Scala since a mathematical model is beyond the scope of this project.

This paper restricts contracts to the definition of ought-to-do instead of ought-to-be following Prisacariu and Schneider \cite{prisacariu2007formal}. This is because --- as per the definition in Section \ref{contract} --- the subjects are expected to be stated explicitly and the actions they should perform to be visible, in contrast to being the product of an action. 

Hvitved's definition of the requirements that needs to be upheld to formalise a contract "ideally" is used to compare our contract language against; see Figure \ref{fig:properties}.

Since only semantics are considered, the implementation leaves out the first requirement, R1.

While there exist several different approaches to contract formalisation, the three main ones are:
\begin{itemize}
    \item Logic-based (deontic) formalisms\footnote{See \cite{hvitved2011contract} pp. 187-188};
    \item Event-condition-action-based formalisms\footnote{See \cite{hvitved2011contract} Section 1.3.2 (pp. 10-12)};
    \item Trace-based formalisms, where a trace-based contract maps to the idea of formalising a contract by a finite sequence of events \cite{andersen2006compositional}.
\end{itemize}

The language this paper reports on is inspired by a variation of trace-based formalism; process algebra.

A contract specification language should aim at fulfilling all the requirements mentioned in Figure \ref{fig:properties}, but so far no CL has been able to encompass all of them \cite{hvitved2011contract}.

\chapter{Contract Language}
This chapter explores the implementation of the prototype language both in terms of design and implementation.

\section{Syntax}\label{language}
In this CL, contracts are described through the expected actions to be taken by the involved parties. In order to determine whether the actual actions (events) adhere to the expected actions (obligations in the contract) contracts are reduced upon the arrival of events. The reduced contract portrays the remaining unfulfilled obligations of the contract. This feature will be explored in section \ref{reduction}. Events represent the transfer of a resource between the instigator and the recipient.

Describing contracts in this DSL is done through expressing and combining subcontracts. A subcontract is a contract used as part of another contract. Usually these are simpler contracts e.g.\ party A paying 100DKK to party B. Subcontracts can be combined to express more complex contracts.
\subsection{Contract Combinators}
\label{combinators}
Combinators follow the idea of subcontracts in that they can be used to describe contracts. In our contract language we have introduced the following combinators.

\subsubsection{\texttt{\textbf{Commitment(f)}}}
\texttt{Commitment} stipulates the expected actions to be performed by the parties involved in the contract. In other words an obligation that must be adhered to. It is the atomic contract of the CL. 
\begin{lstlisting}
case class Commitment(val f: Transaction => Option[Contract]) extends Contract
\end{lstlisting}

\subsubsection{\texttt{\textbf{Or(c1,c2)}}}
\texttt{Or} signifies a choice between two subcontracts (\texttt{c1,c2}). The choice is based on whether a \texttt{Transaction} fits \texttt{c1} or \texttt{c2}.
\begin{lstlisting}
case class Or(val c1: Contract, val c2: Contract) extends Contract
\end{lstlisting}

\subsubsection{\texttt{\textbf{Succ}}}
\texttt{Succ} represent the 'empty' contract, which indicates that all obligations in the contract have been satisfied.
\begin{lstlisting}
case object Succ extends Contract
\end{lstlisting}

\subsubsection{\texttt{\textbf{Fail}}}
\texttt{Fail} depicts a breach of contract or a contract that is impossible to satisfy.
\begin{lstlisting}
case object Fail extends Contract
\end{lstlisting}

\section{Implementation of Language}
In this language, the events are referred to as \texttt{Transaction}s.
\begin{lstlisting}
case class Transaction(ins: Agent, rec: Agent, res: Resource, time: Date)
\end{lstlisting}
A \texttt{Transaction} has the following the parameters: instigator, recipient, resource, time) of which the instigator and recipient are both of type \texttt{Agent}, resource of type \texttt{Resource} and time of type \texttt{Date}. \texttt{Date} is represented as the \texttt{LocalDateTime} from the \texttt{java.time} library. Using the default types of Scala and the Java library has allowed for easy comparison, which will be used when in Section \ref{exampleUseCase}. Expect for \texttt{Date}, these are all custom defined types, to allow for simpler reasoning and easier extension of the language.

Currently, there are 2 different types of \texttt{Resource}s defined, specifically \texttt{Item} and \texttt{MonetaryValue}.
\begin{lstlisting}
sealed trait Resource
case class Item(name: String) extends Resource
case class MonetaryValue(amount: Double) extends Resource
\end{lstlisting}
Where \texttt{Item} represents any item as a \texttt{String} and \texttt{MonetaryValue} represents money as a \texttt{Double}.

Most of the combinators' intended semantics will be reflected upon in Section \ref{reduction}, but \texttt{Commitment}'s function will be touched upon here. The function \texttt{f} within \texttt{Commitment(f)} has been modelled to map from \texttt{Transaction} to \texttt{Option[Contract]} to allow for relative constraints. For example, if a delivery is to occur 3 days after an order is received the timing of the delivery transaction depends on the time of the order. Moreover, \texttt{f} also contains the expected actions that a given transaction ($e$) must fulfil, which will result in \texttt{Some(Contract)} if $e$ fulfils them and \texttt{None} if it does not.

\section{Example Use Case} \label{exampleUseCase}

Based on Section \ref{language} and the requirements from Figure \ref{fig:properties}, this section illustrates the capabilities of the present language by running the concrete example contract from Figure \ref{fig:contract}.

\begin{figure}[!h]
    \centering
    \begin{tcolorbox}
        \textbf{Paragraph 1.} Seller agrees to deliver 100 printer cartridges within 7 days of a received order from the buyer.\par
        \textbf{Paragraph 2.} Buyer agrees to pay seller the total sum of 27 900 DKK according to the terms further set out below.\par
        \textbf{Paragraph 3.} Buyer agrees to pay for the goods half upon ordering, with the remainder due within
        30 days of delivery.\par
        \textbf{Paragraph 4.} If Buyer fails to pay the second half within 30 days, an additional fine of 10\% has
        to be paid within 14 days.\par
    \end{tcolorbox}
    \caption{Slightly modified sales contract between 2 parties \cite{hvitved2011contract}}
    \label{fig:contract}
\end{figure}

\subsection{Order Placement}\label{firstCommitment}

The \texttt{Commitment} combinator will be used to model the commitments between parties of the contract (R3).
It requires a function \texttt{Transaction => Option[Contract]} and it will determine how the contract will branch depending if the \texttt{Transaction} matches. This branching is achieved by:
\begin{itemize}
    \item A Boolean expression. For this specific commitment, the expression \texttt{t.ins == buyer \&\& t.rec == seller \&\& t.res == goods} evaluates to \texttt{True} when the provided transaction is instigated by the buyer, and its recipient is the seller, and the goods correspond to what the buyer intends to buy.
    \item The nature of the \texttt{Option} type, which can either be:
    \begin{itemize}
        \item \texttt{Some[Contract]} --- the situation where the given contract proceeds, or \item \texttt{None} --- the scenario where the given \texttt{Transaction} does not match this specific \texttt{Commitment}.
    \end{itemize}
\end{itemize}

The first \texttt{Commitment} is modelled after the above-mentioned principle:
\begin{lstlisting}
Commitment(t => 
    if (t.ins == buyer && t.rec == seller && t.res == goods) 
        Some(...) else None)
\end{lstlisting}

Note that in the code snippet \texttt{...} is a placeholder for the remainder of the \texttt{Contract} in the case that the \texttt{Transaction} matches this \texttt{Commitment}.

\subsection{First Payment} \label{payment}

The second \texttt{Commitment}, as specified in Paragraph 3 of Figure \ref{fig:contract}, corresponds to the scenario where the buyer upon ordering pays half the worth (13 950 DKK) of the order. This \texttt{Commitment} is implemented by following analogous process as described in Subsection \ref{firstCommitment}: the \texttt{Contract} can branch depending if the \texttt{Transaction} matches and an \texttt{Option[Contract]} is returned.

This is modelled within the language by inserting the following code snippet on the placeholder \texttt{Some(...)} mentioned on \ref{firstCommitment}.
\begin{lstlisting}
Commitment(t2 =>
    if (t2.ins == buyer && t2.rec == seller && t2.res == MonetaryValue(pay/2) && t2.time == t.time)
    Some(...) else None)
\end{lstlisting}

The \texttt{Contract} will branch depending on Boolean expression, which evaluates to \texttt{True} when the instigator and recipient correspond to the buyer and the seller, respectively; but also whether half of the payment is done at the same time the order is placed. Note once more the \texttt{...} placeholder for the remainder of the \texttt{Contract}.

Note that \texttt{pay} is stored as \texttt{double}, which allows in-place arithmetic calculations, fulfilling the in-place expressions requirement (R11).

\subsection{Shipping} \label{shipping}

The act of sending the goods to the buyer is expressed by the following code snippet:
\begin{lstlisting}
Commitment(t3 =>
    if(t3.ins == seller && t3.rec == buyer && t3.res == goods && t3.time < (t.time + Days(7)))
	Some(...) else None)
\end{lstlisting}
The above is meant to be placed in the placeholder mentioned in \ref{payment}.

Note that here the Boolean expression features a relative temporal constraint (R5) expressed by \texttt{t3.time <= (t.time + Days(7)}. It evaluates to \texttt{True} when the \texttt{Transaction} contains a date that is within 7 days of the date order. This ensures that the \texttt{Contract} proceeds when all of the expression is \texttt{True}, including that the 100 printer cartridges are delivered within the promised interval.

Once more, there is a \texttt{...} placeholder that is meant to feature the code presented in the next Subsection.

\subsection{Last Payment} \label{lastPayment}

Paragraphs 3 and 4 of Figure \ref{contract} are modelled together by resorting to the \texttt{or} combinator. This expresses the situation where either the buyer pays the remainder 13 950 DKK within the 30 days of delivery \textbf{or} they pay the initial 13 950 DKK plus an additional fine, increasing the amount due up to 15 345 DKK.

Both \texttt{Commitment}s are expressed as below, but notice that they are combined by having the \texttt{or} keyword in between them.
\begin{lstlisting}
Commitment(t4 =>
    if (t4.ins == buyer && t4.rec == seller && t4.res == MonetaryValue(pay/2) && t4.time < t3.time + Days(30))
		Some(...) else None)
    or
Commitment(t5 => 
    if (t5.ins == buyer && t5.rec == seller && t5.res == MonetaryValue(1.1*(pay/2)) && t5.time <= t3.time + Days(44))
    Some(...) else None)
\end{lstlisting}
The above code snippet is meant to be placed in the placeholder mentioned in \ref{shipping}.

The first \texttt{Commitment}, which contains \texttt{t4}, models Paragraph 3 of Figure \ref{contract} as it assesses (besides the instigator and the recipient) whether the payment of 13 950 DKK is done within the 30 days of delivery.

The second \texttt{Commitment} models Paragraph 4 of Figure \ref{contract} (which serves as a reparations clause). It only comes into effect if the \texttt{Transaction} on the first \texttt{Commitment} is not matched. If any of the composing expressions of the first \texttt{Commitment} evaluates to \texttt{False}, then immediately the \texttt{Transaction} from this second \texttt{Commitment} must be matched so that the \texttt{Contract} can proceed, but the focus here is to ensure that the initial 13 950 DKK are paid on time.

The \texttt{...} placeholders on both \texttt{Commitment}s allow for the last step of the \texttt{Contract} definition, as described on the next Subsection.

\subsection{Finalising the Contract} \label{finalizingContract}

The last step in this example is to model the remainder of the \texttt{Contract}, which consists of placing a successfully finished contract (\texttt{Succ}) on each of the placeholders mentioned in \ref{lastPayment}.

The way this example contract is described in Figure \ref{contract} leaves some room for caveats, which will be discussed later on \ref{canDo}.

\section{Reduction Semantics} \label{reduction}

The present language allows for run-time monitoring (R14), which is the same as reducing a contract. In order to understand how contracts are reduced we will first consider the \texttt{reduce} function and then the combinators \texttt{Commitment} and \texttt{Or} mentioned in section \ref{combinators}.

The way \texttt{reduce} works is that it takes a transaction (\texttt{e}) and matches it to a contract (\texttt{c}). If \texttt{e} matches, then the remainder of the contract (\texttt{c'}) is returned; if not it reports a breach of contract by returning \texttt{Fail}. The matching of \texttt{e} depends on what type of contract \texttt{c} is. The type of \texttt{c} is handled via pattern matching as showed in the snippet of code below.
\begin{lstlisting}
def reduce (e: Transaction) (c: Contract) :Contract = { 
...
    c match {
        case Commitment(f)      => reduceCommitment (f, e)
        case Or(c1,c2)          => reduceOr (c1,c2)
        case Succ | Fail        => Fail
    }
}
\end{lstlisting}
In the case of a contract being \texttt{Fail} or \texttt{Succ} we would expect no events to match them since \texttt{Fail} is impossible to satisfy and a finished contract should not accept anymore transactions.

\subsection{Commitment}

Considering the first case, \texttt{Commitment(f)}, the \texttt{reduceCommitment} function is responsible for handling the reduction of \texttt{Commitment}. It does so by giving the \texttt{f} the \texttt{e} (\texttt{f(e)}) and then checking whether the \texttt{e} matched the conditions of \texttt{f}.
\begin{lstlisting}
def reduceCommitment (f: Transaction => Option[Contract], e: Transaction) = {
    val o = f(e)
    if (o.isDefined) o.get else Fail
}
\end{lstlisting}
If \texttt{e} matches, \texttt{c'} is returned otherwise there is a breach of contract. For example if we have a contract \texttt{con} where \texttt{con} is:
\begin{align*}
&\texttt{Commitment($f_1 \rightarrow^s$ Some(Commitment($f_2 \rightarrow^s$ Some(Succ))))} \\
&\rightarrow^s = \text{Successful match on $f$.} \\
&f_1 = \text{function that only matches on transaction }e_1 \\
&f_2 = \text{function that only matches on transaction }e_2
\end{align*}
Assuming that \texttt{reduce} has been given $e_1$ and \texttt{con}, the reduced contract \texttt{con'} will be:
\begin{align*}
&\texttt{Commitment($f_2 \rightarrow^s$ Some(Succ))}
\end{align*}
If \texttt{con'} were then given $e_2$, the contract would be reduced to \texttt{Succ} indicating that all obligations have been fulfilled. If at any point have any transaction other than $e_1$ or $e_2$ been evaluated against \texttt{con} or \texttt{con'} the result would have been \texttt{Fail}.

\subsection{Or}

\texttt{Or} also uses a helper function to handle its reduction. \texttt{reduceOr} takes the 2 subcontracts held by \texttt{Or(c1,c2)} and starts by matching \texttt{e} against \texttt{c1}. The remainder of \texttt{c1} (\texttt{c1p}) is then checked for non-failure. If $\texttt{c1p} != \texttt{Fail}$ \texttt{c1p} is returned otherwise the reduced contract of \texttt{c2} is returned.
\begin{lstlisting}
def reduceOr (c1: Contract, c2: Contract): Contract = {
    val c1p = reduce (e) (c1)
    lazy val c2p = reduce (e) (c2)
    c1p match {
        case Fail => c2p
        case _    => c1p
    }
}
\end{lstlisting}
As shown in the above code snippet whenever a transaction fits one of the subcontracts \texttt{c1} or \texttt{c2}, the other is no longer part of the remaining contract. For example assuming we have a contract \texttt{cor} defined as
\begin{align*}
    \texttt{Or(Commitment($f_1 \rightarrow^s$ Some(c3)),} \\
    \texttt{Commitment($f_2 \rightarrow^s$ Some(c4)))}
\end{align*}
If \texttt{cor} is matched with $e_2$ using \texttt{reduce} then the reduced contract \texttt{cor'} = \texttt{c4}. If the transaction had been $e_1$ instead \texttt{cor'} = \texttt{c3}. Hence the choice of branch is determined by which transaction the \texttt{Or} contract is matched against.

\chapter{Discussion}

After exposing the main features of the language, alongside with an example, this chapter resorts to other aspects that have not been mentioned before and evaluates their degree of success by comparing them to the definitions from Figure \ref{fig:properties}. We finish with some aditional remarks and reflections.

\section{Achieved Requirements} \label{canDo}

\subsection{Absolute Temporal Constraints (R4)}
The language achieves the Absolute Temporal Constraints (R4) requirement, despite that not being portrayed in Section \ref{exampleUseCase} is to adhere to absolute temporal constraints (R4). Consider that instead of the first half of the payment being on the same time as the event occurred, one could have specified it to be on the 29/12/2019, this would limit the contract in question, but would be possible by simply exchanging \texttt{t.time} with \texttt{Date(2019, 12, 29)}.

\subsection{Potentially Infinite Contract (R8)}
Consider the Subsection \ref{finalizingContract}. For the last parts of the contract, one could choose to indicate that the contract has been completed by adding \texttt{Succ} in both placeholders \texttt{...} in the code snippet from Subsection \ref{lastPayment}. 

However, reading Paragraph 1 carefully reveals that the seller agrees to deliver the printer cartridges when an order is received from the buyer. This could suggest that this a potentially infinite contract (R8) --- that does not reach completion (\texttt{Succ}) as it would simply wait until the next time an order from the buyer is received. If it was to be interpreted this way, one could simply use recursion and insert \texttt{salesContract(buyer, seller, goods, pay)} instead of \texttt{Succ} on the placeholder (assuming that there we have defined a template that does all of the above called \texttt{salesContract}).

\subsection{History-Sensitive Commitments (R10)}
The history-sensitive commitments (R10) requirement is not mentioned in Section \ref{exampleUseCase}, but the language is still able to model.

Consider the example from Figure \ref{fig:contract} and the code snippet from Section \ref{lastPayment}: if the contract is determined by a maximum number of printer cartridges, when that number is reached or exceeded then the contract terminates. Implementation-wise we would need to add 2 parameters to our \texttt{salesContract(buyer, seller, goods, pay, ordered, max)} which would then be added to our contract.
\begin{lstlisting}
Commitment(t => 
    if (t.ins == buyer && t.rec == seller && t.res == goods) 
        Some(...) else None)
or
Commitment(ts => 
    if (t.ins == buyer && t.rec == seller && t.res == goods && ordered <= max)
    Some (Succ) else None)
\end{lstlisting}
\texttt{Commitment(t => ...)} is the initial \texttt{Commitment}, while \texttt{Commitment(ts => ...)} indicates that when we have reached the maximum number of printer cartridges, the contract will conclude. Of course for this to be truly history-sensitive we would update our call inside \texttt{Commitment(t4 => ...)} and \texttt{Commitment(t5 => ...)} from above to \texttt{salesContract(buyer, seller, goods, pay, ordered + 100, max)}.


\section{Requirements Achieved with Limitations}

\subsection{Reparation Clauses (R6)}
It should be noted that while the language is able to consider reparation clauses (R6), as seen in Paragraph 4 in Figure \ref{fig:contract}, it is limited to which kind of reparations. Currently only the \texttt{or} operator is able to express a choice between the 2 subcontracts, hence either buyer is going to pay the remainder of the total sum within the 30 days of delivery or they pay the remainder along with the additional fine. Consider a scenario where the buyer is allowed to return the goods --- in such case there a choice is not suited, but instead an interleaving of the payment subcontract and the returning subcontract --- so either could be successfully handled without losing the other.

\section{Unachieved Requirements}

\subsection{Time-Varying, External Dependencies (R9)}
Despite the fact the language is able to express instantaneous events, like seen in Paragraph 1 of Figure \ref{fig:contract}, it does not allow for continuous events as there is simply no way of expressing that in its current form. In terms of R9, it would be possible to add observables: consider another paragraph in Figure \ref{fig:contract} that states that the contract happens annually and should be adjusted according to inflation. Since it would require to expand the current contract language in order to express this recurring event, this requirement is not fulfilled.

\subsection{Parametrised Contracts (R12) and Isomorphic encoding (R13)}
The convenience features, R12 and R13, are not covered in the language. R12 is not satisfied because there is no instantiation pattern --- instead, functions are made, and these can be called to implement a specific type of contract, which is basically what the pattern would need. Adding to this the language does not satisfy one-to-one correspondence with the informal paper contract (R13). Some infix operators are featured, but these could be expanded.

\subsection{Blame Assignment (R15)}
When evaluating contracts, it is not possible to assign blame (R15) since currently the \texttt{reduce} function reports on a breach of contract, not the party who originated the breach.

\subsection{Amenability to Compositional Analysis (R16)}
While the combinator \texttt{Commitment} has allowed the language to be quite expressive, it has come at a cost. By making it contain a lambda expression that returns an \texttt{Option[Contract]}, the creation of template contracts can become quite complex and hard to reason about. Moreover, it has made it impossible to perform analysis (R16).

This means that when we move into our thesis, the prototype contract language we have created may need to be refactored. Yet, the aim of being able to use property-based testing for analysis is still possible as we are able to do run-time monitoring of contracts.

\section{Reflections on Choice of Hosting Language}

The choice for Scala have proved beneficial since we have been able to use many of the Java's standard library classes. This came particularly handy when implementing features related to time, such as \texttt{Date}, but we do believe this particular language is still too convoluted for modelling contracts in DSL. It still requires a lot of syntax to express certain functionalities, which ends up defeating the purpose of using the functional programming style. On the other hand, Scala does have some interesting features --- the ability to implement custom infix operators, the \texttt{apply} method which allows for a very short way to instantiate new objects, to name a few. But before one could take advantage of these features, it was necessary to define them which, as mentioned in the previous point, added some noise to what could be a very short DSL.

\section{Final Reflection and Future Work}
The contract language we have modelled ended up being quite expressive and enables us to fulfil a lot of the requirements from Figure \ref{fig:properties}. Yet, while the language implementation is sensible and compact the templates turned out to be very long due to the complexity of the \texttt{Commitment} combinator. This is something we would like to improve in the future.

It it worth noting we managed to implemented the intended semantics for our combinators in our run time monitoring which is the foundation on which we can use property-based testing for analyses.

\begin{appendices}

\chapter{}

\begin{figure}[!h]
\begin{tcolorbox}[fontupper=\small]
\begin{list}{R\arabic{qcounter}:~}{\usecounter{qcounter}}
    \item Contract model, contract language, and a formal semantics.
    \item Contract participants.
    \item (Conditional) commitments.
    \item Absolute temporal constraints.
    \item Relative temporal constraints.
    \item Reparation clauses.
    \item Instantaneous and continuous actions.
    \item Potentially infinite and repetitive contracts.
    \item Time-varying, external dependencies (observables).
    \item History-sensitive commitments.
    \item In-place expressions.
    \item Parametrised contracts.
    \item Isomorphic encoding.
    \item Run-time monitoring.
    \item Blame assignment.
    \item Amenability to (compositional) analysis.
\end{list}
\end{tcolorbox}
\caption{Properties of contract languages \cite{hvitved2011contract}.}
\label{fig:properties}
\end{figure}

\end{appendices}

\bibliographystyle{apalike}
\bibliography{references}
\printbibliography


\end{document}