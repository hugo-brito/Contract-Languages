\documentclass{ituthesis}



\settitle{Domain-Specific Languages\\for Analysing and Testing\\Properties of Contracts}
\setauthor{Hugo Brito \\ \href{mailto:hubr@itu.dk}{hubr@itu.dk} \\ \\ Jonas Andersen \\ \href{mailto:haja@itu.dk}{haja@itu.dk}}
\setsupervisor{Willard Rafnsson}
\setextrasupervisor{Patrick Bahr}
\setdate{December 2019}

\begin{document}
% Uncomment the following to set the default language of the document to Danish. This affects hyphenation as well as headers and the like.
%\selectlanguage{danish}

% no hyphenation
\hyphenchar\font=-1

\frontmatter

\thetitlepage
\newpage

% \begin{abstract}
% This is a placeholder for the abstract.
% % We develop, present and explain the work developed around a declarative language for the formalisation of and analysis of contracts. The present has taken inspiration from the available literature on the matter.
% % In this paper, starting from a simple example contract, we implement a very simple Contract Specification Language\footnote{A formal language for contracts: \url{https://www.deondigital.com/2019/03/introducing-csl/}}, test it and reason about it. The goal is to provide the reader with an introductory view on the topic, as well as laying the foundations for the next step of this process, which will be to use Property-Based Testing\footnote{What is Property Based Testing?:\\ \url{https://hypothesis.works/articles/what-is-property-based-testing/}} to improve the necessary computations as well as on contracts built with this tool.
% \end{abstract}

% \begin{otherlanguage}{danish}
%   \begin{abstract}
%     Dette er et resumé på dansk, som er det alternative sprog i dokumentet.
%   \end{abstract}
% \end{otherlanguage}

\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter

%from memoir documentation:
%TeX tries very hard to keep text lines justified while keeping the interword spacing as constant as possible, but sometimes fails and complains about an overfull hbox.
%The default mode for LaTeX typesetting is \fussy where the (variation of) interword spacing in justified text is kept to a minimum. Following the \sloppy declaration there may be a much looser setting of justified text.
%Additionally the class provides the \midsloppy declaration which allows a setting somewhere between \fussy and \sloppy.
%fewer overfull lines than \fussy, and fewer obvious large interword spacing than with \sloppy.
%the memoir manual also uses \midsloppy!
\midsloppy
% try harder to avoid widows and orphans
\sloppybottom

\chapter{Introduction}

%% Possible commands and headers:
% (Copied from the original template)

% \originally{History of the Makhnovist Movement; 1923}
% \joint{Peter Arshinov}
% \chapter{Something in Between}
% Somewhere at sometime...

% \section{A Section}
% \subsection{A Subsection}
% Some text.
% \subsubsection{A subsubsection}
% More text here.

% Here's some verbatim text:
% \begin{verbatim}
% data Vect : Nat -> Type -> Type where
%   Nil : Vect 0 a
%   (::) : a -> Vect n a -> Vect (1 + n) a
% \end{verbatim}

% \joint{Emma Goldman}
% \chapter{At the Same Time Somewhere Else}
% ... happened something else

% Here's some mathematics:
% \begin{displaymath}
%   \frac{
%     \Gamma, x:\tau_1\;\vdash\; e \;:\; \tau_2
%   }{
%     \Gamma\;\vdash\;\lambda x : \tau_1 . e \;:\; \tau_1\to\tau_2}
% \end{displaymath}

% \originally{My autobiography; 1934}
% \chapter{Conclusion}
% Finished

% Report guidelines:
% \begin{itemize}
%     \item 15 pg. + 2 pg per group member (19 pg max)
%     \item Go for around 17 pages. Should be self-contained, someone who was not in these meetings should be able to understand the report. 
%     \item Report should be lean and concrete, it is okay if it takes up less pages.
%     \item If unsure about omitting or including stuff in report, can consult them.
% \end{itemize}
% We should start working on sections, so we can get feedback from them as much as possible.

% -------------------------

% \begin{itemize}
%     \item Explain what a contract language is
%     \item Explain what's out there, in terms of Research
%     \item What are Contract Languages used for?
%     \begin{itemize}
%         \item Use an example as motivation to tell a story
%         \item Use an example to show how is used and how implemented (doesn't have to be own)
%         \item tell a story, we want to describe something and why ours looks different (because it explains what it is supposed to express)
%     \end{itemize}
% 	\item Show our contract (show the actual contract and explain with code examples how it works)
% 	\begin{itemize}
% 	    \item What is our intention of doing it like so?
% 	    \item Define our language (Evaluation function should do this)
% 	\end{itemize}
% 	\item Pick some properties that could be interesting to consider for our language, but do not implement property based testing.
% \end{itemize}
%
% A well written F\# (Scala) example should be fine, not necessary to formally define in logic.
In this report we will investigate how to develop our own contract language in the domain of a simple exchange of resources. We will start by giving a brief introduction to the core concepts of this paper and the problem we are trying to solve. The concept of a contract language will be more thoroughly explored in the methodology section.

% \item Explain what a contract language is
\section{What is a Domain-Specific Language?}
% Does it answer the question: What are Contract Languages used for?

% very good explanation on what a https://www.jetbrains.com/mps/concepts/domain-specific-languages/
A domain-specific language (from now on DSL) is a programming language tailored to a specific problem domain. Contrary to what happens with a general-purpose programming language, which use is not restricted to a particular type of problem or machine, a DSL is built with the sole purpose of modelling and expressing a specific set of problems \cite{van2000domain}.

By default, it is less complex to use than a general-purpose programming language and it is meant to be developed in close contact with domain experts, as ultimately these will constitute its users \cite{dsl}.

\section{What is a Contract Language?}
A contract language is a DSL for contracts. Unlike most other DSLs the purpose of a contract language is to build contracts that can be treated like data, hence it can be executed several times. Besides this, these contracts are subjected to monitoring and various user-defined analyses \cite{andersen2006compositional}.

Unfortunately, not all contracts can be implemented using a contract language as it requires the given contract to be unambiguous in nature, such as financial contracts and in general contracts governing the exchange of resources.

% but it is stricter in the sense that it is part of smaller subset of the DSLs that are built and used only in the context of Contracts. Specifically contracts that tend to be unambiguous in nature, hence Financial Contract, Exchange of Resources etc.
% This kind of contracts allows for an extreme simplification of the DSL since it does not deal with, e.g. perishable goods, etc. By the fact they deal mainly with amounts of money, which does not require, e.g. somewhere to be stored, does not perish, can be easily transferred (does not require transportation), they are simpler to model, reason and work with.

\section{Problem formulation}
The point of this report is for us to gain an understanding of how to implement and use a DSL to describe contracts. With that in mind we aim to do the following:

\begin{itemize}
    \item Gain insight to the literature in this area along with what kind of contracts one can implement.
    \item Create a working prototype of our contract language.
    \item Be able to do simple analysis on the language.
\end{itemize}

All of the aforementioned have the underlying goal of understanding the benefit of contract languages.


\chapter{Methodology}
% Does it answer the question: Explain what's out there, in terms of Research
% *One of the keypoints of the meetings:\\
% Explain what's out there, in terms of Research*

% Explain the approach to our paper, how did we make the language and how did we get there.

In this paper we use the inductive approach to determine how to develop our contract language. This section will lay out the current research in the area and how we define a contract language.

\section{Background}
DSLs have been around almost as long as the the existence of humans, as we always find a way to simplify language within certain domains. Musicians use musical notation, lawyers use legal-language and we programmers use code. Nowadays most programmers use general-purpose languages that might contain DSLs to make the solving of certain problems easier, whereas older languages such as Cobol were made as dedicated languages to solve a certain range of problems \cite{van2000domain}. A good analogy is for a DSL is to think of a crafting a specialised tool for a specific task, instead of using non-specific tool for such task.

However, the idea of using a DSL to give a formal description to financial contracts in code, where not introduced until the 2000's by Peyton-Jones, Eber \& Seward. They specifically explored how to express financial contracts, such as bonds, stocks, etc. and even made a combinator library \cite{peyton2000composing}. This type of DSL is known as a contract language. To this day, contract languages are still most commonly used in the domain of the financial industry. One of the first companies to utilise this was LexiFi\footnote{\url{https://www.lexifi.com/}} which has since been followed by most banks and other companies such as SimCorp\footnote{\url{https://www.simcorp.com/}}.

Andersen et al. have taken an extra step by building a general contract language that can encompass more than just financial contracts, and they have done so by extending Peyton-Jones, Eber \& Seward's language. This language formalises contracts governing the exchange of resources, hence it encompasses the exchange of money, goods and services among multiple parties \cite{andersen2006compositional}. The aforementioned paper laid the groundwork for the contract language developed by Deon Digital\footnote{\url{https://www.deondigital.com/}}, which has provided us with valuable guidance on how to approach, design and build our own contract language.

Hvitved published in 2011 «A Survey of Formal Languages and Models for Contracts» where he has compared many of the existing DSLs and formal ways to model contracts\footnote{See \cite{hvitved2011contract} chapter 1, pp. 25}. He has noticed that none of the models he studied had a focus on blame assignment within this domain. We believe that this fact has been his motivation to produce the paper «A trace-based model for multiparty contracts». This focus has been one of the most recent advances in the field. Blame assignment introduces another step in the direction of a more complete DSL for contracts since the underlying goal of a DSL for contracts is to provide all the parts of such contract not only if, when and why the contract has been breached, but by whom as well. Blame assignment can therefore be an important aspect to consider when modelling such class of DSLs as it potentially saves a lot of time when understanding the origin of the breach. It could potentially help figuring out who should be accounted for repairs, and it would also report contract breaches as the contract is being executed. These can come, for example, in the form of a deadline that has not been respected, the act of executing some action explicitly forbidden by the contract, etc. Being able to model contracts that account for these aspects has been proven as a very effective way to describe real-world contracts. A noticeable advantage of this is being able to simulate possible outcomes of future events and to issue reminders for deadlines that are closing in --- which could potentially make the difference between breaching a contract or not, and by consequence being able to avoid paying for repairs/compensation \cite{hvitved2012trace}.

It is a widely accepted idea that faulty software is costly and can potentially compromise an entire project \cite{expensivesoftware}. With the broader adoption of DSLs by many financial organisations, the concerns regarding correctness (by the means of mathematical proof) and the ability to simultaneously express useful, real-world contracts has emerged. An important development in the field has been the idea of alienating the aspects of simulation and computation of a contract from the core of the language the contract is specified in. This idea allows to bring algebraic properties closer to the formalisation of contracts and, by doing so, allowing for symbolic (rather than numerical) computation and mathematical proof. This work has been elaborated on the «Certified Symbolic Management of Financial Multi-party Contracts» paper \cite{bahr2015certified} where a contract language is presented along with a type system that enforces that contracts specified in such language follow the principle of causality. These findings also allow for implementations within contract management, a feature that is certainly appreciated by these institutions since they have many contracts and parties to manage. Other features of the language described in aforementioned paper include type inference, reduction semantics, contract specialisation (partial evaluation), and horizon inference. Overall, and perhaps one of the most interesting aspects this paper brings is the robustness in the language brought by certification of its properties by using the Coq proof
assistant\footnote{Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs. More info: \url{https://github.com/coq/coq}}.

\section{Why a DSL for Contracts?}
% Motivation section
% Use an example to show how is used and how implemented (doesn't have to be own) 
% Based on an example: *Why a DSL*
% what is it good for in this case?
The previous section answers a big portion of this question, but it is important to mention that one of the main benefits of formalising contracts using a DSL is that it allows for automatic contract life-cycle management (CLM). CLM deals with managing a contract portfolio, specifically the creation, negotiation, approval, execution and analysis of contracts. A CSL normally handles the parts of CLM that require validation, execution and analysis of contracts \cite{hvitved2011contract}.

\section{Contract Formalisation Requirements} \label{requirements}
When formalising contracts it is vital to consider a formal contract model and a formal contract language separately. A formal model refers to a semantic mathematical model of a contract while a formal language refer to a syntactic representation of a contract. When creating a contract language both of these should ideally be combined in terms of the language's semantics \cite{hvitved2011contract}. However, since we are modelling our language after J. Andersen et al., we focus solely on implementing the semantics in Scala.

When referring to contracts we follow the definition of Hvitved:
\begin{displayquote}
\textit{"A contract is a legally binding agreement between two or more parties. The agreement is a normative description of commitments between the parties of the contract, that is a contract describes the expected actions to be performed by the participants of the contract."}
\cite{hvitved2011contract}
\end{displayquote}

Hence, we restrict contracts to the definition of ought-to-do instead of ought-to-be. Following this we use Hvitved's definition of the requirements that needs to be upheld to formalise a contract "ideally":

\begin{list}{R\arabic{qcounter}:~}{\usecounter{qcounter}}
    \item Contract model, contract language, and a formal semantics.
    \item Contract participants.
    \item (Conditional) commitments.
    \item Absolute temporal constraints.
    \item Relative temporal constraints.
    \item Reparation clauses.
    \item Instantaneous and continuous actions.
    \item Potentially infinite and repetitive contracts.
    \item Time-varying, external dependencies (observables).
    \item History-sensitive commitments.
    \item In-place expressions.
    \item Parametrised contracts.
    \item Isomorphic encoding.
    \item Run-time monitoring.
    \item Blame assignment.
    \item Amenability to (compositional) analysis \cite{hvitved2011contract}.
\end{list}

Due to us only considering the semantics we do not consider the first requirement R1 in our implementation.

While there exist several different approaches to contract formalisation, the three main ones are:
\begin{itemize}
    \item Logic-based (deontic) formalisms\footnote{See \cite{hvitved2011contract} pp. 187-188};
    \item Event-condition-action-based formalisms\footnote{See \cite{hvitved2011contract} Section 1.3.2 (pp. 10-12)};
    \item Trace-based formalisms, where a trace-based contract maps to the idea of formalising a contract by a finite sequence of events \cite{andersen2006compositional}.
\end{itemize}

In this report we follow a variation of trace-based formalism specifically process algebra since it is derived from J. Andersen et al., which our language is based upon.

It is in our understanding that a contract specification language should aim at fulfilling all the requirements mentioned in 2.3. But as Hvitved had expressed before, none had so far been able to encompass all of them \cite{hvitved2011contract}.


\chapter{Implementation}
% Lines $1$ and $2$ instantiate two \texttt{Agent}s: Alice and Bob. In the universe of our language, these entities constitute parties of a contract: they own \texttt{Resource}s that can be transmitted between those parties.\newline
% Line $3$ instantiates an \texttt{Item}. An \texttt{Item} is a sub-type of the \texttt{trait Resource}.\newline

% The basic anatomy of a \texttt{Transaction} is:
% \begin{itemize}
%     \item The \texttt{instigator} is the \texttt{Agent} that originates the \texttt{Transaction} at hand,
%     \item The \texttt{recipient} consists of another \texttt{Agent} and, as the name implies, it receives the \texttt{Resource} the \texttt{Transaction} refers to,
%     \item The \texttt{resource} field holds an object of the \texttt{Resource} type, which we will see later that can represent by different entities. The goal is to express the idea of \texttt{resource} being passed from \texttt{instigator} to \texttt{recipient},
%     \item The \texttt{timeStamp} holds a \texttt{Date} which will later help us with certain details of contracts that could, for instance, involve deadlines.
% \end{itemize}
Before diving into the specifics of our contract language we will introduce the universe in which it exists.

The events --- the entities we use in order to evaluate a given contract, are called \texttt{Transaction} and are instantiated by taking the parameters \texttt{(instigator, recipient, resource, time)} of which the instigator and recipient are both of type \texttt{Agent}, resource of type \texttt{Resource} and time of type \texttt{Date}. These are all our own custom defined types, to allow for simpler reasoning and easier extension of the language. Currently, we have defined 2 different types of \texttt{Resource}s, specifically \texttt{Item} and \texttt{MonetaryValue}. Where \texttt{Item} represents any item as a \texttt{String} and \texttt{MonetaryValue} represents money as a \texttt{Double}. \texttt{Date} is represented as the \texttt{LocalDateTime} from the \texttt{java.time} library. Using the default types of scala and the java library has allowed us to compare values, which we will use when creating contract templates.

Our contract language consists of the following combinators:
\begin{lstlisting}
case class Commitment(val f: Transaction => Option[Contract]) extends Contract
case class Or(val c1: Contract, val c2: Contract) extends Contract
case object Succ extends Contract
case object Fail extends Contract
\end{lstlisting}

Where \texttt{Commitment} represents the base of the language and allows subcontracts being within the same scope, similar to J.Andersen et al.'s \texttt{transmit(a1,a2,r,t).c}. The \texttt{Or} combinator indicates a choice meaning that depending on the event it will either choose \texttt{c1} or \texttt{c2}. The two last combinators \texttt{Succ} and \texttt{Fail} indicate the successful evaluation of a contract and that a given contract failed, respectively. Besides this our \texttt{Fail} is also used to indicate that there has been a breach of contract.

Now that an understanding of our universe have been established we will now use the requirements from section \ref{requirements} to illustrate what our language is able to do, based on figure \ref{fig:contract}.

\begin{figure}[!h]
    \centering
    \begin{tcolorbox}
        \textbf{Paragraph 1.} Seller agrees to deliver 100 printer cartridges within 7 days of an received order from the buyer.\par
        \textbf{Paragraph 2.} Buyer agrees to pay seller the total sum of 27 900 DKK according to the terms further set out below.\par
        \textbf{Paragraph 3.} Buyer agrees to pay for the goods half upon receipt, with the remainder due within
        30 days of delivery.\par
        \textbf{Paragraph 4.} If Buyer fails to pay the second half within 30 days, an additional fine of 10\% has
        to be paid within 14 days.\par
    \end{tcolorbox}
    \caption{Slightly modified sales contract between 2 parties \cite{hvitved2011contract}}
    \label{fig:contract}
\end{figure}

First, we model our contract participants (R2) and commitments (R3) through our \texttt{Commitment} combinator. Looking at Paragraph 1 in figure \ref{fig:contract} we could model the part of receiving the order in our language like so.
\begin{lstlisting}
Commitment(t => 
    if (t.ins == buyer && t.rec == seller && t.res == goods) 
        Some(...) else None)
\end{lstlisting}
Here we are checking whether the buyer made the order (the instigator of the \texttt{Transaction}), the seller is receiving it and that the goods are what they are supposed to be, in this case \texttt{goods=Item("100 printer cartridges")}. \par

Next we have to make sure that half the payment (13 950 DKK) for the cartridges is received before the order is send to the buyer, like specified in Paragraph 3. The following code snippet we put inside the \texttt{Some(...)} from above.
\begin{lstlisting}
Commitment(t2 =>
    if (t2.ins == buyer && t2.rec == seller && t2.res == MonetaryValue(pay/2) && t2.time == t.time)
    Some(...) else None)
\end{lstlisting}
Again we check whether our instigator and recipient is correct, but also check whether half of the payment has been received and that the time of the payment is the same as the time of the order. In here \texttt{pay} is represented as a \texttt{double}, so we are able to do calculations on it and thereby, fulfil in-place expressions (R11), which we are also able to do on the dates, thanks to the \texttt{java.time} library. Another requirement that our language fulfils, but that is not showcased in this example is to adhere to absolute temporal constraints (R4). If we imagine that instead of the first half of the payment being on the same time as the event occurred, we could have specified it to be on the 29/12/2019, this would limit the contract in question, but would be possible by simply exchanging \texttt{t.time} with \texttt{Date(2019, 12, 29)}.

Now the cartridges are ready to be sent to the buyer, like above we replace the next code snippet with the \texttt{...} from above.
\begin{lstlisting}
Commitment(t3 =>
    if(t3.ins == seller && t3.rec == buyer && t3.res == goods && t3.time < (t.time + Days(7)))
	Some(...) else None)
\end{lstlisting}
Here the \texttt{t3.time <= (t.time + Days(7)} defines define a relative temporal constraint (R5) on the the third transaction, since the transaction received needs to have a date that is within 7 Days of the order, as we need to ensure that the 100 printer cartridges is delivered within the promised interval.

The last parts that still lack modelling are Paragraphs 3 and 4. These two will be done together since we use our \texttt{or} combinator here, as we expect the buyer to either pay the 13 950 DKK within the 30 days of delivery or pay the additional fine bringing the total to 15 345 DKK. Like above the following code should go into \texttt{...} of the last function.
\begin{lstlisting}
Commitment(t4 =>
    if (t4.ins == buyer && t4.rec == seller && t4.res == MonetaryValue(pay/2) && t4.time < t3.time + Days(30))
		Some(...) else None)
    or
Commitment(t5 => 
    if (t5.ins == buyer && t5.rec == seller && t5.res == MonetaryValue(1.1*(pay/2)) && t5.time <= t3.time +Days(44))
    Some(...) else None)
\end{lstlisting}
%
The \texttt{Commitment} containing \texttt{t4} models Paragraph 3 as it checks whether the payment of 13 950 DKK is paid within the 30 days of delivery. The other \texttt{Commitment} models Paragraph 5 which is a reparations clause, that only comes into effect if the 13 950 DKK is not paid on time.

It should be noted that while the language is able to consider reparation clauses (R6) as seen in Paragraph 4 in figure \ref{fig:contract} it is limited to which kind of reparations. Currently we only have the \texttt{or} operator that expresses a choice between the 2 subcontracts, hence either buyer is going to pay the remainder of the total sum within the 30 days of delivery or pay the remainder along with the additional fine. Let us say we wanted the buyer to also have the possibility of returning the goods then we would not want that to be a choice, but an interleaving of the payment subcontract and the returning subcontract, so either could be successfully handled without loosing the other.

For the last parts of the contract, we can choose to indicate the contract has been completed by adding \texttt{Succ} in both of the \texttt{...} in the above code snippet. However, if we read Paragraph 1 carefully, it stipulates that the seller agrees to deliver the printer cartridges when an order is received from the buyer. This could suggest that this a potentially infinite contract (R8), that doesn't reach completion as it would simply wait until the next time an order from the buyer is received. If it was to be interpreted this way, we could simply use recursion by putting \texttt{salesContract(buyer, seller, goods, pay)} instead of \texttt{Succ}, assuming that there we have defined a template that does all of the above called \texttt{salesContract}.

A requirement that is not considered in figure \ref{fig:contract}, but our language is still able to model is history-sensitive commitments (R10). Imagine that the contract is determined by a maximum number of printer cartridges, when that number is reached or exceeded then the contract terminates. Implementation-wise we would need to add 2 parameters to our \texttt{salesContract(buyer, seller, goods, pay, ordered, max)} which would then be added to our contract.
\begin{lstlisting}
Commitment(t => 
    if (t.ins == buyer && t.rec == seller && t.res == goods) 
        Some(...) else None)
or
Commitment(ts => 
    if (t.ins == buyer && t.rec == seller && t.res == goods && ordered <= max)
    Some (Succ) else None)
\end{lstlisting}
\texttt{Commitment(t => ...)} is the initial \texttt{Commitment}, while \texttt{Commitment(ts => ...)} indicates that when we have reached the maximum number of printer cartridges, the contract will conclude. Of course for this to be truly history-sensitive we would update our call inside \texttt{Commitment(t4 => ...)} and \texttt{Commitment(t5 => ...)} from above to \texttt{salesContract(buyer, seller, goods, pay, ordered + 100, max)}.

Lastly, our language allows for run-time monitoring, which is probably the most important requirement. If we again take a look at figure \ref{fig:contract}, once this contract has been instantiated we would like to be able 'throw' transactions at it and have it return the reduced contract, if the transaction fulfils the subcontract. Let us define a transaction that will fulfil the first part of the contract.
\begin{lstlisting}
Transaction(buyer, seller, goods, Date())
\end{lstlisting}{}
Like specified in our first \texttt{Commitment} we here say that the instigator must be the buyer, recipient the seller, the goods must be \texttt{Item("100 printer cartridges")} and the date is simply whenever the transaction is executed.

Putting this into our evaluation function 
\begin{lstlisting}
def evalC (e: Transaction) (c: Contract) :Contract = { 
    ...
    c match {
        case Commitment(f)      => reduceCommitment (f, e)
        case Or(c1,c2)          => reduceOr (c1,c2)
        case Succ | Fail        => Fail
    }
}
\end{lstlisting}
\texttt{evalC(x)(c)}, where $x$ is our transaction and $c$ the contract defined above. It will immediately go to the \texttt{case Commitment(f) => reduceCommitment(f,t)}. Where the function in the \texttt{Commitment} is run and if the return value is not \texttt{None} then returns the remainder of the contract ($c'$).

\chapter{Discussion}
After having seen what our implementation is able to do, it is poignant to point out where it falls short. The requirements our language is unable to fulfil are: R7, R9, R12, R13, R15 and R16 from Section \ref{requirements}.

Despite the fact the language is able to express instantaneous events, like seen in Paragraph 1 of figure \ref{fig:contract}, it does not allow for continuous events as there is simply no way of expressing that in its current form. In terms of R9 it would be possible to add observables, say we add another paragraph in figure \ref{fig:contract} that says the contract happens annually and should be adjusted according to inflation. However, since it would require to expand the current contract language it is not fulfilled.

The convenience features, R12 and R13, are not covered in the language. R12 is not satisfied because there is no instantiation combinator --- instead we have only made functions that can be called to implement a specific type of contract, which is basically what the combinator would need. Our language does not satisfy one-to-one correspondence with the informal paper contract (R13). We do provide some infix operators, but nothing more.

When evaluating contracts we are not able to assign blame (R15), since we currently only report on a breach of contract, not the party who broke it.

While the combinator \texttt{Commitment} has allowed us to make our language quite expressive, it has come at a cost. By making it contain a lambda expression that returns an \texttt{Option[Contract]}, the creation of template contracts can become quite complex and hard to reason about. Moreover, it has made it impossible to perform analysis (R16), which is one of the main goals we set when starting out the project.

This means that when we move into our thesis the prototype contract language we have created will not allow us work on interesting properties on contracts and analyse them using property-based testing, simply because we contain all of our information in functions. This means that we would need to refactor the language before we could find any meaningful properties.

\chapter{Conclusion}
The contract language we have made does create a good foundation for us to move on with in our thesis, but even though it fulfils a lot of the requirements for an ideal language, the complexity and trade offs we have made, means that some of the language fundamentals needs to be rethought.

The main issue is that we are unable to do any simple analysis, which means that any property-based testing we would like to do on properties of contracts would currently be impossible. The next step is to refactor the code base to allow for analysis, so this would become possible.

\bibliographystyle{apalike}
\bibliography{references}
\printbibliography


\end{document}
