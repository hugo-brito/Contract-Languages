\documentclass{ituthesis}



\settitle{Domain-Specific Languages\\for Analysing and Testing\\Properties of Contracts}
\setauthor{Hugo Brito \\ \href{mailto:hubr@itu.dk}{hubr@itu.dk} \\ \\ Jonas Andersen \\ \href{mailto:haja@itu.dk}{haja@itu.dk}}
\setsupervisor{Willard Rafnsson}
\setextrasupervisor{Patrick Bahr}
\setdate{December 2019}

\begin{document}
% Uncomment the following to set the default language of the document to Danish. This affects hyphenation as well as headers and the like.
%\selectlanguage{danish}

% no hyphenation
\hyphenchar\font=-1

\frontmatter

\thetitlepage
\newpage

% \begin{abstract}
% This is a placeholder for the abstract.
% % We develop, present and explain the work developed around a declarative language for the formalisation of and analysis of contracts. The present has taken inspiration from the available literature on the matter.
% % In this paper, starting from a simple example contract, we implement a very simple Contract Specification Language\footnote{A formal language for contracts: \url{https://www.deondigital.com/2019/03/introducing-csl/}}, test it and reason about it. The goal is to provide the reader with an introductory view on the topic, as well as laying the foundations for the next step of this process, which will be to use Property-Based Testing\footnote{What is Property Based Testing?:\\ \url{https://hypothesis.works/articles/what-is-property-based-testing/}} to improve the necessary computations as well as on contracts built with this tool.
% \end{abstract}

% \begin{otherlanguage}{danish}
%   \begin{abstract}
%     Dette er et resumé på dansk, som er det alternative sprog i dokumentet.
%   \end{abstract}
% \end{otherlanguage}

\cleardoublepage
\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter

%from memoir documentation:
%TeX tries very hard to keep text lines justified while keeping the interword spacing as constant as possible, but sometimes fails and complains about an overfull hbox.
%The default mode for LaTeX typesetting is \fussy where the (variation of) interword spacing in justified text is kept to a minimum. Following the \sloppy declaration there may be a much looser setting of justified text.
%Additionally the class provides the \midsloppy declaration which allows a setting somewhere between \fussy and \sloppy.
%fewer overfull lines than \fussy, and fewer obvious large interword spacing than with \sloppy.
%the memoir manual also uses \midsloppy!
\midsloppy
% try harder to avoid widows and orphans
\sloppybottom

\chapter{Introduction}

Picture the scenario of a banking institution with thousands of requests for their financial products, being those in the form of home loans, credit cards, personal loans, etc. How could one assess those requests on a timely manner? How could one even manage all the active contracts? How would it be in the case of a breached contract? Certainly not with pen and paper.

In this digital era, contracts have certainly moved digital too. In this paper we will implement and discuss a framework for expressing contracts digitally by the means of contract-specification language. The goal is to design a prototype language that allows to express contracts between parties --- commitments between them that will later be checked against actual taken actions. Having the first in place, and then informing the program of the latter will result on the evaluation of the remainder of the given contract. This means to know what commitments are yet to be fulfilled or, if the current contract has been breached, or if it has finished successfully (all parties have delivered what they promised).

This framework will allow their users to:
\begin{itemize}
    \item Build templates for contracts of many kinds --- a simple purchase, a loan, exchange of currency. \item Manage active contracts.
    \item Reason about both contract templates and potential contracts, and even to build strong contract templates that disallow negative effects on both parties, among others.
\end{itemize}

\section{What is a Contract?}
\label{contract}
The concept of contract will often arise throughout this paper. In this context, we resort to the definition of contract by Hvitved:
\begin{displayquote}
\textit{"A contract is a legally binding agreement between two or more parties. The agreement is a normative description of commitments between the parties of the contract, that is a contract describes the expected actions to be performed by the participants of the contract."}
\cite{hvitved2011contract}
\end{displayquote}

\section{What is a Domain-Specific Language?}
% Does it answer the question: What are Contract Languages used for?

As previously mentioned, a we wish to easily express and reason about contracts. To achieve this, we built a prototype which consists of a domain-specific language. A domain-specific language (DSL) is a programming language tailored to a specific problem domain \cite{whatsisadsl2005}. Whereas with a general-purpose programming language, which use is not restricted to a particular type of problem or machine, a DSL is built with the sole purpose of modelling and expressing a specific set of problems \cite{van2000domain}. %comment from willard: Consider a different citation style ("plain", or, if you need a little more, "alpha")., not sure what he means.
Typically, it is less complex to use than a general-purpose programming language and it is meant to be developed in close contact with domain experts, as ultimately these will constitute its users \cite{dsl}.

\section{What is a Contract Language?}
A Contract Language (CL) is a DSL tailored for contracts. Its purpose is to express contracts that can be treated like data, hence it can be executed several times. By having this construct, one can effectively manage all aspects of the given contract. One example is when modelling a contract, one can assume that it is composed of a limited set of commitment between parties. If it is known that one party has fulfilled one of the commitments, very easily the remainder can be evaluated, e.g. the set of remaining commitments that are yet to be fulfilled is returned. Moreover, these contracts are subjected to monitoring and various user-defined analyses \cite{andersen2006compositional}.

Approaches to modelling contracts could diverge immensely, but we focus on contracts that are unambiguous in their nature, such as financial contracts and in general contracts governing the exchange of resources.

\section{Problem formulation} % This does not quite reflect what is written in Project Base. I know that the reason you are doing this project is to learn stuff. However, the reader does not care why you did this; they only care about what you did. Focus on the product; that's what the report should document.
With the ultimate goal of coming up with a prototype of language to build and evaluate contracts, this paper reports on:
\begin{itemize}
    \item A domain-specific languages built for the purpose of expressing and operating contracts digitally.
    \item The aspects considered when building the present prototype language.
    \item The implementation of the language.
    \item A discussion regarding the strengths and pitfalls of this particular implementation.
\end{itemize}

\chapter{Methodology}
% Does it answer the question: Explain what's out there, in terms of Research
% *One of the keypoints of the meetings:\\
% Explain what's out there, in terms of Research*

% Explain the approach to our paper, how did we make the language and how did we get there.

In this paper we use the inductive approach to determine how to develop our contract language. This section will lay out the current research in the area and how we define a contract language.

\section{Background}
DSLs have been around almost as long as the the existence of humans, as we always find a way to simplify language within certain domains. Musicians use musical notation, lawyers use legal-language and we programmers use code. Nowadays most programmers use general-purpose languages that might contain DSLs to make the solving of certain problems easier, whereas older languages such as SQL\footnote{«\textit{SQL, which stands for Structured Query Language, is a programming language that is used to communicate with and manipulate databases.}» \cite{whatisSQL}} were made as dedicated languages to solve a certain range of problems \cite{van2000domain}.

However, the idea of using a DSL to give a formal description to contracts in code, was not introduced until the 2000's by Peyton-Jones, Eber \& Seward. They specifically explored how to express financial contracts, such as bonds, stocks, etc. and even made a combinator library \cite{peyton2000composing}. This type of DSL is known as a contract language. To this day, contract languages are still most commonly used in the domain of the financial industry.

Andersen et al.\ have taken an extra step by building a general contract language that can encompass more than just financial contracts, and they have done so by extending Peyton-Jones, Eber \& Seward's language. This language formalises contracts governing the exchange of resources, hence it encompasses the exchange of money, goods and services among multiple parties \cite{andersen2006compositional}. The aforementioned paper laid the groundwork for the contract language developed by Deon Digital\footnote{\url{https://www.deondigital.com/}}, which has provided us with valuable guidance on how to approach, design and build our own contract language.

In the paper «A trace-based model for multiparty contracts» blame assignment was introduced. Before, it was possible to discern if, when and why a contract had been breached, but not by whom. Blame assignment considers who the perpetrator is adding substantial value to the field as knowing the origin of the breach can potentially save a lot of time by avoiding court. It also reports contract breaches as the contract is being executed. These can come, for example, in the form of a deadline that has not been respected, the act of executing some action explicitly forbidden by the contract, etc. Being able to model contracts that account for these aspects has been proven as a very effective way to describe real-world contracts. A noticeable advantage of this is being able to simulate possible outcomes of future events and to issue reminders for deadlines that are closing in --- which could potentially make the difference between breaching a contract or not, and by consequence being able to avoid paying for repairs/compensation \cite{hvitved2012trace}.

It is a widely accepted idea that faulty software is costly and can potentially compromise an entire project \cite{expensivesoftware}. With the broader adoption of DSLs by many financial organisations, the concerns regarding correctness (by means of mathematical proof) and the ability to simultaneously express useful, real-world contracts has emerged. An important development in the field has been the idea of alienating the aspects of simulation and computation of a contract from the core of the language the contract is specified in. This idea allows to bring algebraic properties closer to the formalisation of contracts and, by doing so, allowing for symbolic (rather than numerical) computation and mathematical proof. This work has been elaborated on the «Certified Symbolic Management of Financial Multi-party Contracts» paper \cite{bahr2015certified} where a contract language is presented along with a type system that enforces that contracts specified in such language follow the principle of causality. These findings also allow for implementations within contract management, a feature that is certainly appreciated by these institutions since they have many contracts and parties to manage. Other features of the language described in aforementioned paper include type inference, reduction semantics, contract specialisation (partial evaluation), and horizon inference. Overall, and perhaps one of the most interesting aspects this paper brings is the robustness in the language brought by certification of its properties by using the Coq proof
assistant\footnote{Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs. More info: \url{https://github.com/coq/coq}}.

\section{Why a DSL for Contracts?}
% Motivation section
% Use an example to show how is used and how implemented (doesn't have to be own) 
% Based on an example: *Why a DSL*
% what is it good for in this case?
The previous section answers a big portion of this question, but it is important to mention that one of the main benefits of formalising contracts using a DSL is that it allows for automatic contract life-cycle management (CLM). CLM deals with managing a contract portfolio, specifically the creation, negotiation, approval, execution and analysis of contracts. A CSL normally handles the parts of CLM that require validation, execution and analysis of contracts \cite{hvitved2011contract}.

\section{Contract Formalisation Requirements} \label{requirements}
When formalising contracts it is vital to consider a formal contract model and a formal contract language separately. A formal model refers to a semantic mathematical model of a contract while a formal language refer to a syntactic representation of a contract. When creating a contract language both of these should ideally be combined in terms of the language's semantics \cite{hvitved2011contract}. In this paper, we focus solely on implementing the semantics in Scala since a mathematical model is beyond the scope of this project.
% comment from patrick: It is perfectly fine for you not to consider a formal mathematical model. But I don’t see how this follows from following Andersen et al. Rather say that a mathematical model is beyond the scope of your work here.

In this paper we restrict contracts to the definition of ought-to-do instead of ought-to-be following Prisacariu and Schneider \cite{prisacariu2007formal}. This is because we - as per the definition in Section \ref{contract} - expect the subjects to be stated explicitly and the actions they should perform to be visible, in contrast to being the product of an action. 

Hvitved's definition of the requirements that needs to be upheld to formalise a contract "ideally" is used to compare our contract language against; see Figure \ref{fig:properties}.

% comment from patrick: I didn’t see any discussion of why “ought-to-be” was considered for your language.

\begin{figure}[!h]
\begin{tcolorbox}[fontupper=\small]
\begin{list}{R\arabic{qcounter}:~}{\usecounter{qcounter}}
    \item Contract model, contract language, and a formal semantics.
    \item Contract participants.
    \item (Conditional) commitments.
    \item Absolute temporal constraints.
    \item Relative temporal constraints.
    \item Reparation clauses.
    \item Instantaneous and continuous actions.
    \item Potentially infinite and repetitive contracts.
    \item Time-varying, external dependencies (observables).
    \item History-sensitive commitments.
    \item In-place expressions.
    \item Parametrised contracts.
    \item Isomorphic encoding.
    \item Run-time monitoring.
    \item Blame assignment.
    \item Amenability to (compositional) analysis.
\end{list}
\end{tcolorbox}
\caption{Properties of contract languages \cite{hvitved2011contract}.}
\label{fig:properties}
\end{figure}

\newpage
Due to us only considering the semantics we do not consider the first requirement R1 in our implementation.

While there exist several different approaches to contract formalisation, the three main ones are:
\begin{itemize}
    \item Logic-based (deontic) formalisms\footnote{See \cite{hvitved2011contract} pp. 187-188};
    \item Event-condition-action-based formalisms\footnote{See \cite{hvitved2011contract} Section 1.3.2 (pp. 10-12)};
    \item Trace-based formalisms, where a trace-based contract maps to the idea of formalising a contract by a finite sequence of events \cite{andersen2006compositional}.
\end{itemize}

In this report our language is inspired by a variation of trace-based formalism; process algebra.

A contract specification language should aim at fulfilling all the requirements mentioned in Figure \ref{fig:properties}, but so far no CL have been able to encompass all of them \cite{hvitved2011contract}.


\chapter{Implementation}
% Lines $1$ and $2$ instantiate two \texttt{Agent}s: Alice and Bob. In the universe of our language, these entities constitute parties of a contract: they own \texttt{Resource}s that can be transmitted between those parties.\newline
% Line $3$ instantiates an \texttt{Item}. An \texttt{Item} is a sub-type of the \texttt{trait Resource}.\newline

% The basic anatomy of a \texttt{Transaction} is:
% \begin{itemize}
%     \item The \texttt{instigator} is the \texttt{Agent} that originates the \texttt{Transaction} at hand,
%     \item The \texttt{recipient} consists of another \texttt{Agent} and, as the name implies, it receives the \texttt{Resource} the \texttt{Transaction} refers to,
%     \item The \texttt{resource} field holds an object of the \texttt{Resource} type, which we will see later that can represent by different entities. The goal is to express the idea of \texttt{resource} being passed from \texttt{instigator} to \texttt{recipient},
%     \item The \texttt{timeStamp} holds a \texttt{Date} which will later help us with certain details of contracts that could, for instance, involve deadlines.
% \end{itemize}
Before diving into the semantics of the implementation the universe in which it exists will be introduced followed by an example contract being implemented in the language.

\section{Syntax}
\label{syntax}
The events --- the entities we use in order to evaluate a given contract, are called \texttt{Transaction} and are instantiated by taking the parameters \texttt{(instigator, recipient, resource, time)} of which the instigator and recipient are both of type \texttt{Agent}, resource of type \texttt{Resource} and time of type \texttt{Date}. These are all our own custom defined types, to allow for simpler reasoning and easier extension of the language. Currently, we have defined 2 different types of \texttt{Resource}s, specifically \texttt{Item} and \texttt{MonetaryValue}. Where \texttt{Item} represents any item as a \texttt{String} and \texttt{MonetaryValue} represents money as a \texttt{Double}. \texttt{Date} is represented as the \texttt{LocalDateTime} from the \texttt{java.time} library. Using the default types of Scala and the Java library has allowed us to compare values, which we will use when creating contract templates.

Our contract language consists of the following combinators:
\begin{lstlisting}
case class Commitment(val f: Transaction => Option[Contract]) extends Contract
case class Or(val c1: Contract, val c2: Contract) extends Contract
case object Succ extends Contract
case object Fail extends Contract
\end{lstlisting}

Where \texttt{Commitment} represents the base of the language and allows subcontracts being within the same scope, similar to J.Andersen et al.'s \texttt{transmit(a1,a2,r,t).c}. The \texttt{Or} combinator indicates a choice meaning that depending on the event it will either choose \texttt{c1} or \texttt{c2}. The two last combinators \texttt{Succ} and \texttt{Fail} indicate the successful evaluation of a contract and that a given contract failed, respectively. Besides this our \texttt{Fail} is also used to indicate that there has been a breach of contract.

\section{Example}

Now that an understanding of the universe have been established we will now use the requirements from Figure \ref{fig:properties} to illustrate what the language can do, based on Figure \ref{fig:contract}.

\begin{figure}[!h]
    \centering
    \begin{tcolorbox}
        \textbf{Paragraph 1.} Seller agrees to deliver 100 printer cartridges within 7 days of an received order from the buyer.\par
        \textbf{Paragraph 2.} Buyer agrees to pay seller the total sum of 27 900 DKK according to the terms further set out below.\par
        \textbf{Paragraph 3.} Buyer agrees to pay for the goods half upon receipt, with the remainder due within
        30 days of delivery.\par
        \textbf{Paragraph 4.} If Buyer fails to pay the second half within 30 days, an additional fine of 10\% has
        to be paid within 14 days.\par
    \end{tcolorbox}
    \caption{Slightly modified sales contract between 2 parties \cite{hvitved2011contract}}
    \label{fig:contract}
\end{figure}

First, we model our contract participants (R2) and commitments (R3) through our \texttt{Commitment} combinator. Looking at Paragraph 1 we could model the part of receiving the order like so.
\begin{lstlisting}
Commitment(t => 
    if (t.ins == buyer && t.rec == seller && t.res == goods) 
        Some(...) else None)
\end{lstlisting}
Here we are checking whether the buyer made the order (the instigator of the \texttt{Transaction}), the seller is receiving it and that the goods are what they are supposed to be, in this case \texttt{goods=Item("100 printer cartridges")}. \par

Next we have to make sure that half the payment (13 950 DKK) for the cartridges is received before the order is send to the buyer, like specified in Paragraph 3. The following code snippet we put inside the \texttt{Some(...)} from above.
\begin{lstlisting}
Commitment(t2 =>
    if (t2.ins == buyer && t2.rec == seller && t2.res == MonetaryValue(pay/2) && t2.time == t.time)
    Some(...) else None)
\end{lstlisting}
Again we check whether our instigator and recipient is correct, but also check whether half of the payment has been received and that the time of the payment is the same as the time of the order. In here \texttt{pay} is represented as a \texttt{double}, so we are able to do calculations on it and thereby, fulfil in-place expressions (R11), which we are also able to do on the dates, thanks to the \texttt{java.time} library. Another requirement that our language fulfils, but that is not showcased in this example is to adhere to absolute temporal constraints (R4). If we imagine that instead of the first half of the payment being on the same time as the event occurred, we could have specified it to be on the 29/12/2019, this would limit the contract in question, but would be possible by simply exchanging \texttt{t.time} with \texttt{Date(2019, 12, 29)}.

Now the cartridges are ready to be sent to the buyer, like above we replace the next code snippet with the \texttt{...} from above.
\begin{lstlisting}
Commitment(t3 =>
    if(t3.ins == seller && t3.rec == buyer && t3.res == goods && t3.time < (t.time + Days(7)))
	Some(...) else None)
\end{lstlisting}
Here the \texttt{t3.time <= (t.time + Days(7)} defines define a relative temporal constraint (R5) on the the third transaction, since the transaction received needs to have a date that is within 7 Days of the order, as we need to ensure that the 100 printer cartridges is delivered within the promised interval.

The last parts that still lack modelling are Paragraphs 3 and 4. These two will be done together since we use our \texttt{or} combinator here, as we expect the buyer to either pay the 13 950 DKK within the 30 days of delivery or pay the additional fine bringing the total to 15 345 DKK. Like above the following code should go into \texttt{...} of the last function.
\begin{lstlisting}
Commitment(t4 =>
    if (t4.ins == buyer && t4.rec == seller && t4.res == MonetaryValue(pay/2) && t4.time < t3.time + Days(30))
		Some(...) else None)
    or
Commitment(t5 => 
    if (t5.ins == buyer && t5.rec == seller && t5.res == MonetaryValue(1.1*(pay/2)) && t5.time <= t3.time +Days(44))
    Some(...) else None)
\end{lstlisting}
%
The \texttt{Commitment} containing \texttt{t4} models Paragraph 3 as it checks whether the payment of 13 950 DKK is paid within the 30 days of delivery. The other \texttt{Commitment} models Paragraph 5 which is a reparations clause, that only comes into effect if the 13 950 DKK is not paid on time.

It should be noted that while the language is able to consider reparation clauses (R6) as seen in Paragraph 4 in Figure \ref{fig:contract} it is limited to which kind of reparations. Currently we only have the \texttt{or} operator that expresses a choice between the 2 subcontracts, hence either buyer is going to pay the remainder of the total sum within the 30 days of delivery or pay the remainder along with the additional fine. Let us say we wanted the buyer to also have the possibility of returning the goods then we would not want that to be a choice, but an interleaving of the payment subcontract and the returning subcontract, so either could be successfully handled without loosing the other.

For the last parts of the contract, we can choose to indicate the contract has been completed by adding \texttt{Succ} in both of the \texttt{...} in the above code snippet. However, if we read Paragraph 1 carefully, it stipulates that the seller agrees to deliver the printer cartridges when an order is received from the buyer. This could suggest that this a potentially infinite contract (R8), that doesn't reach completion as it would simply wait until the next time an order from the buyer is received. If it was to be interpreted this way, we could simply use recursion by putting \texttt{salesContract(buyer, seller, goods, pay)} instead of \texttt{Succ}, assuming that there we have defined a template that does all of the above called \texttt{salesContract}.

A requirement that is not considered in Figure \ref{fig:contract}, but our language is still able to model is history-sensitive commitments (R10). Imagine that the contract is determined by a maximum number of printer cartridges, when that number is reached or exceeded then the contract terminates. Implementation-wise we would need to add 2 parameters to our \texttt{salesContract(buyer, seller, goods, pay, ordered, max)} which would then be added to our contract.
\begin{lstlisting}
Commitment(t => 
    if (t.ins == buyer && t.rec == seller && t.res == goods) 
        Some(...) else None)
or
Commitment(ts => 
    if (t.ins == buyer && t.rec == seller && t.res == goods && ordered <= max)
    Some (Succ) else None)
\end{lstlisting}
\texttt{Commitment(t => ...)} is the initial \texttt{Commitment}, while \texttt{Commitment(ts => ...)} indicates that when we have reached the maximum number of printer cartridges, the contract will conclude. Of course for this to be truly history-sensitive we would update our call inside \texttt{Commitment(t4 => ...)} and \texttt{Commitment(t5 => ...)} from above to \texttt{salesContract(buyer, seller, goods, pay, ordered + 100, max)}.

\section{Semantics}
\subsection{Example}
Lastly, our language allows for run-time monitoring (R14), which is probably the most important requirement. If we again take a look at Figure \ref{fig:contract}, once this contract has been instantiated we would like to be able 'throw' transactions at it and have it return the reduced contract, if the transaction fulfils the subcontract. Reduced contract being what is left of the contract after a part of it has been fulfilled. A subcontract is a small part of the contract. In the example contract gone through in the last section each \texttt{Commitment} represents a subcontract. If the \texttt{Commitment} concerned with receiving the order of 100 printer cartridges from the buyer receives a transaction that satisfies it, this \texttt{Commitment} will 'disappear' and the reduced contract will be the remaining subcontracts. 

A transaction that will be able to do just this can be seen below.
\begin{lstlisting}
Transaction(buyer, seller, goods, Date())
\end{lstlisting}{}
Like specified in our first \texttt{Commitment} we here say that the instigator must be the buyer, recipient the seller, the goods must be \texttt{Item("100 printer cartridges")} and the date is simply whenever the transaction is executed.

Putting this into our evaluation function 
\begin{lstlisting}
def evalC (e: Transaction) (c: Contract) :Contract = { 
    ...
    c match {
        case Commitment(f)      => reduceCommitment (f, e)
        case Or(c1,c2)          => reduceOr (c1,c2)
        case Succ | Fail        => Fail
    }
}
\end{lstlisting}
\texttt{evalC(x)(c)}, where $x$ is our \texttt{Transaction} and $c$ the contract defined above. It will immediately go to the \texttt{case Commitment(f) => reduceCommitment(f,t)}. Where the function in the \texttt{Commitment} is run and if the return value is not \texttt{None} then returns the remainder of the contract ($c'$).

\subsection{Intended Semantics}

As specified in section \ref{syntax} there exits 4 different contract patterns in the CL, two of which are combinators. Below is an explanation of their intended semantics and how this is reflected in the implementation of the \texttt{evalC} function.

\textbf{\texttt{Commitment(f)}} \\
\texttt{Commitment} represents the transfer of a resource between the instigator and the recipient. It is the atomic contract of the CL. \texttt{f} will contain a check to see whether a given \texttt{Transaction} fulfils a criteria specified within \texttt{f}, if it does it will return \texttt{Some(Contract)} else it will return \texttt{None}, which indicates a breach of contract. The \texttt{evalC} function makes use of this through the helper function \texttt{reduceCommitment}.
\begin{lstlisting}
def reduceCommitment (f: Transaction => Option[Contract], e: Transaction) = {
    val o = f(e)
    if (o.isDefined) o.get else Fail
}
\end{lstlisting}
The way \texttt{reduceCommitment} enforces the semantics of the \texttt{Commitment(f)} is by evaluating \texttt{f} and returning the remainder of the contract, if it has been been evaluated to \texttt{Some(Contract)} otherwise it will return \texttt{Fail} to indicate a breach of contract. \\\\
%
\textbf{\texttt{Or(c1,c2)}} \\
Like mentioned in section \ref{syntax} the \texttt{Or} is supposed to reflect a choice between two subcontracts (\texttt{c1,c2}). The choice is based on whether a \texttt{Transaction} fits \texttt{c1} or \texttt{c2}.
\begin{lstlisting}
def reduceOr (c1: Contract, c2: Contract): Contract = {
    val evalC1 = evalC (e) (c1)
    lazy val evalC2 = evalC (e) (c2)
    evalC1 match {
        case Fail => evalC2
        case _    => evalC1
    }
}
\end{lstlisting}
The \texttt{reduceOr} function implements this by first evaluating \texttt{c1} to \texttt{evalC1}, if \texttt{evalC1} is a non-failure, then \texttt{evalC1} is returned. In the case that it is not a non-failure \texttt{c2} is evaluated to \texttt{evalC2} and returned. As shown in the above code snippet whenever a transaction fits one of the subcontracts, the other is no longer part of the contract. \\\\
\textbf{\texttt{Succ}} \\
\texttt{Succ} represent the 'empty' contract, which indicates that all subcontracts have been satisfied. Since a finished contract should not accept any transactions it evaluates to \texttt{Fail} if given one. \\\\
\textbf{\texttt{Fail}} \\
\texttt{Fail} depicts a breach of contract or a contract that is impossible to satisfy.

Another function in our language, that is not a combinator or used in the above example is \texttt{seq}. The idea of this function is to to allow for sequential execution of subcontracts that do not have any relative constraints. The way it is expressed is using algebraic laws to define the two given subcontracts in terms their respective combinators.


\chapter{Discussion}
After having seen what our implementation is able to do, it is poignant to point out where it could be improved. All the requirements mentioned below stem from Figure \ref{fig:properties}.

Despite the fact the language is able to express instantaneous events, like seen in Paragraph 1 of Figure \ref{fig:contract}, it does not allow for continuous events as there is simply no way of expressing that in its current form. In terms of R9 it would be possible to add observables, say we add another paragraph in Figure \ref{fig:contract} that says the contract happens annually and should be adjusted according to inflation. However, since it would require to expand the current contract language it is not fulfilled.

The convenience features, R12 and R13, are not covered in the language. R12 is not satisfied because there is no instantiation pattern --- instead we have made functions that can be called to implement a specific type of contract, which is basically what the pattern would need. Adding to this the language does not satisfy one-to-one correspondence with the informal paper contract (R13). We do provide some infix operators, but was not aiming to implementing these things given the short time frame.

When evaluating contracts we are not able to assign blame (R15), since we currently report on a breach of contract, not the party who broke it.

While the combinator \texttt{Commitment} has allowed us to make our language quite expressive, it has come at a cost. By making it contain a lambda expression that returns an \texttt{Option[Contract]}, the creation of template contracts can become quite complex and hard to reason about. Moreover, it has made it impossible to perform analysis (R16).

This means that when we move into our thesis the prototype contract language we have created may need to be refactored. Yet, the aim of being able to use property-based testing for analysis is still possible as we are able to do run-time monitoring of contracts.

\chapter{Conclusion}

% The contract language we have made does create a good foundation for us to move on with in our thesis, but even though it fulfils a lot of the requirements for an ideal language, the complexity and trade offs we have made, means that some of the language fundamentals needs to be rethought.

% The main issue is that we are unable to do any simple analysis, which means that any property-based testing we would like to do on properties of contracts would currently be impossible. The next step is to refactor the code base to allow for analysis, so this would become possible.

Building the present prototype has exposed some interesting aspects we would like to refer:
\begin{itemize}
    \item The functional programming style seems to be extremely suited for the task. Very easily one can extend or alter the project with a few lines of code and, when adding this to how compact the style is, it becomes comes somewhat easy to model and reason about the result.
    \item Functional programming also seems to very suited to build a domain-specific language. Certain definitions took only line of code, and this is certainly a convenience.
    \item The choice for Scala seemed like a good idea since we could use many of the Java's standard library classes. This came particularly handy when implementing features related to time, such as \texttt{Date}, but we do believe this particular language is still too convoluted for this particular purpose. It still requires a lot of syntax to express certain functionalities, which ends up defeating a bit the purpose of using the functional programming style.
    \item On the other end, Scala does have some interesting features --- the ability to implement custom infix operators, the \texttt{apply} method which allows for a very short way to instantiate new objects, to name a few. But before one could take advantage of these features, it was necessary to define them which, as mentioned in the previous point, added some noise to what could be a very short DSL.
    \item Having had the language defined, the template contracts still required a lot of definitions and heavy knowledge of the language implementation.
    \item Considering the last two bullet points, on a future iteration it could be beneficial to experiment with a more compact language such as Haskell which has also been the standard for this kind of projects.
    \item Functionality was achieved but at with a big trade off for expressiveness. The language implementation is sensible and compact, but the templates turned out to be very long. We were aiming at an easier way to describe the templates.
    \item Looking back at Hvitved's survey on contract languages, some important features were left unmodelled, as exposed in the Discussion chapter.

\end{itemize}

\bibliographystyle{apalike}
\bibliography{references}
\printbibliography


\end{document}
